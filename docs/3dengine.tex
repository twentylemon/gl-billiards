% COSC 3P98 Project
% gl-billiards
% Dan Lapp
% Taras Mychaskiw

\section{3D Engine}

	\subsection{Loading Models}
	To use 3d models that were more complex than simple primitive shapes, we needed to import our own custom models.  We decided to use 3D Studio Max to create and texture all of our models. The main advantage of this approach is that all vertex coordinates and texture mapping coordinates can be handled by 3D Studio and loaded into OpenGL. Programming our pool table directly in OpenGL would be virtually impossible.\\
	We exported our models into the \textit{.3ds} file format. This is a binary file format that is fairly simple to parse, well documented, and natively supported by 3D Studio. The binary data is organized into a heirarchy of chunks. We abstracted a 3d model into it's own class \textit{Model}. Each object in the scene, such as \textit{Table}, and \textit{Cue} extends \textit{Model}. Any model class is initialized as follows
	\begin{equation}
	Table{\enskip}table = Model(std::string{\enskip}modelPath,{\enskip}std::string{\enskip}texturePath)
	\end{equation}
The texture specified must be a \textit{.bmp} file for the texture parser to read. When the model is initialized, the 3ds parser skips through the file chunks and stores three things. First are the actual \textit{(x, y, z)} coordinates of the vertices, then the polygon list, which is the order to draw the vertices. Last is the texture mapping coordinates.\\
	The bitmap parser we used reads in a \textit{.bmp} file used as a texture for the model. The texture must have a width and a height that is a power of 2, and must be maximum 2048 pixels in any dimension. The textures are then handed to OpenGL and a texture id is saved in our model.

	%end{Loading Models}

	\subsection{Calculating Normals}
	We calculated our own normals to be used with game lighting. This way we could get the vertex normals without having to parse the smoothing groups in the \textit{.3ds} file. Since every polygon in this file format is a triangle, to calculate normals was fairly simple. The pseudocode for this is as follows

	\begin{center}
	\begin{pseudocode}[framebox]{calculateNormals}{polygonList}

	\LOCAL{numPolygons}[vertices.size]\\
	\FOREACH i \in \text{polygonList} \DO
	\BEGIN
	\vec{v_1} \gets\vec{i.P_1} - \vec{i.P_2}\\
	\vec{v_2} \gets\vec{i.P_1} - \vec{i.P_3}\\
	\vec{n} \gets \vec{v_1}\times \vec{v_2}\\\\
		\FOREACH coordinate \in \text{i} \DO
		\BEGIN
			\text{add } \vec{n} \text{ to normalList[i.coordinate]}\\
			\text{numPolygons[i.coordinate]}++
		\END
	\END
	\\\\
	\FOREACH i \in \text{normalList} \DO
		\IF{numPolygons[i] > 1}
		\THEN{i (1.0 / numPolygons[i])}
    \end{pseudocode}
    \end{center}
	
	First, for each triangular polygon \textit{$(P_1, P_2, P_3)$} polygonList, calculate two vectors $\vec{v_1}, \vec{v_2}$ we can use for the cross product. The cross product gives us a vector $\vec{n}$ perpendicular to the polygon face. We keep track of which surfaces are next to each vertex. Then in the final \textit{for} loop we average the polygon normals for each vertex normal.

	%\end{Calculating Normals}

	\subsection{Optimizations}
	To optimize our 3d rendering, we used OpenGL display lists. Large floating point arrays used to store vertex coordinates require alot of memory to manage these arrays. Using display lists significantly reduces the overhead associated with storing our arrays. We noticed a significant speed increase of at least 5 times with display lists. Using benchmarks, we found that our user interface used $\sim43\%$ of the programs computation time, and physics used $\sim27\%$, so speeding up the model rendering provided a noticable speed increase.

	%\end{Optimizations}
	

	


%\end{3D Engine}